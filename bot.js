const path = require('path')
const Telegraf = require('telegraf')
const session = require('telegraf/session')
const rateLimit = require('telegraf-ratelimit')
const I18n = require('telegraf-i18n')

const { bot: botLog, db: dbLog } = require('./helpers/logger')
const { db } = require('./database')
const { processExpiredVotes } = require('./handlers')
const { processStartupCleanup, startCleanupInterval } = require('./helpers/message-cleanup')
const { startPeriodicSync: startCasSync } = require('./helpers/cas-sync')
const {
  stats,
  errorHandler,
  contextLoader,
  globalBanCheck,
  casBan,
  spamCheck,
  dataPersistence,
  emojiInject
} = require('./middlewares')
const { registerAllRoutes } = require('./routes')

// Track bot start time
global.startDate = new Date()

/**
 * Create and configure the bot instance
 */
const createBot = () => {
  const bot = new Telegraf(process.env.BOT_TOKEN, {
    telegram: { webhookReply: false }
  })

  // Attach database to context
  bot.context.db = db

  return bot
}

/**
 * Configure i18n (internationalization)
 */
const createI18n = () => {
  return new I18n({
    directory: path.resolve(__dirname, 'locales'),
    defaultLanguage: 'en',
    defaultLanguageOnMissing: true
  })
}

/**
 * Configure session middleware
 */
const configureSession = (bot) => {
  // User session
  bot.use(session({ ttl: 60 * 5 }))

  // Group session
  bot.use(session({
    property: 'group',
    getSessionKey: (ctx) => {
      if (ctx.from && ctx.chat && ['supergroup', 'group'].includes(ctx.chat.type)) {
        return `${ctx.chat.id}`
      }
      return null
    },
    ttl: 60 * 5
  }))
}

/**
 * Skip channel posts (not processed by bot)
 */
const skipChannelPosts = () => {
  // Intentionally empty - channel posts are ignored
}

/**
 * Handle my_chat_member updates (bot added/removed from groups)
 */
const handleBotAddedToGroup = require('./handlers/bot-added')
const handleMyChatMemberUpdates = (ctx, next) => {
  if (ctx.update.my_chat_member) {
    botLog.debug({ update: ctx.update }, 'my_chat_member update')
    return handleBotAddedToGroup(ctx)
  } else {
    return next()
  }
}

/**
 * Spam check orchestrator middleware
 * Coordinates CAS ban and AI spam check
 */
const spamCheckOrchestrator = async (ctx, next) => {
  // Check both new messages and edited messages
  // Spammers send clean messages first, then edit them to spam
  if ((!ctx.message && !ctx.editedMessage) || !ctx.from) {
    return next(ctx)
  }

  // Normalize ctx.message for edited messages so all downstream code
  // (CAS ban, spam check, quickRiskAssessment, etc.) works uniformly
  if (ctx.editedMessage && !ctx.message) {
    ctx.message = ctx.editedMessage
  }

  // Skip if already flagged as spam (e.g., by global ban)
  if (ctx.state && ctx.state.isSpam) {
    return next(ctx)
  }

  // CAS ban check
  const casBanned = await casBan(ctx)
  if (casBanned) {
    if (!ctx.state) ctx.state = {}
    ctx.state.isSpam = true
    return next(ctx)
  }

  // AI spam check
  const aiSpam = await spamCheck(ctx)
  if (aiSpam) {
    if (!ctx.state) ctx.state = {}
    ctx.state.isSpam = true
  }

  return next(ctx)
}

/**
 * Register all middlewares in order
 */
const registerMiddlewares = (bot, i18n) => {
  // 1. Skip channel posts
  bot.on(['channel_post', 'edited_channel_post'], skipChannelPosts)

  // 2. Handle bot added/removed from groups
  bot.use(handleMyChatMemberUpdates)

  // 3. Global error handler
  bot.use(errorHandler)

  // 4. Statistics
  bot.use(stats)

  // 5. Rate limiting (5 requests per second)
  bot.use(rateLimit({ window: 1000, limit: 5 }))

  // 6. Sessions (user + group)
  configureSession(bot)

  // 7. Internationalization
  bot.use(i18n.middleware())

  // 7.5. Inject custom emoji map into i18n
  bot.use(emojiInject)

  // 8. Load context (user, group, member data)
  bot.use(contextLoader)

  // 9. Global ban check
  bot.use(globalBanCheck)

  // 10. Spam checks (CAS + AI)
  bot.use(spamCheckOrchestrator)

  // 11. Data persistence (runs after handlers)
  bot.use(dataPersistence)
}

// Explicitly list update types we need â€” ensures edited_message is always included
// even if a previous setWebhook/getUpdates call restricted the list
const ALLOWED_UPDATES = [
  'message',
  'edited_message',
  'callback_query',
  'my_chat_member',
  'channel_post',
  'edited_channel_post'
]

/**
 * Launch bot in webhook or polling mode
 */
const launchBot = (bot) => {
  if (process.env.BOT_DOMAIN) {
    const hookPath = `/LyAdminBot:${process.env.BOT_TOKEN}`
    const port = process.env.WEBHOOK_PORT || 2200
    return bot.launch({
      webhook: {
        domain: process.env.BOT_DOMAIN,
        hookPath,
        port
      }
    }).then(() => {
      // Re-set webhook with explicit allowed_updates (launch() doesn't pass it)
      const domain = process.env.BOT_DOMAIN.replace(/^https?:\/\//, '')
      return bot.telegram.setWebhook(`https://${domain}${hookPath}`, {
        allowed_updates: ALLOWED_UPDATES
      })
    }).then(() => {
      botLog.info({
        mode: 'webhook',
        port,
        allowedUpdates: ALLOWED_UPDATES
      }, 'Bot started')
    })
  }

  return bot.launch({
    polling: { allowedUpdates: ALLOWED_UPDATES }
  }).then(() => {
    botLog.info({ mode: 'polling', allowedUpdates: ALLOWED_UPDATES }, 'Bot started')
  })
}

/**
 * Main initialization
 */
const init = () => {
  const bot = createBot()
  const i18n = createI18n()

  registerMiddlewares(bot, i18n)
  registerAllRoutes(bot)

  // Wait for database connection before launching
  db.connection.once('open', async () => {
    dbLog.info('Connected to MongoDB')
    await launchBot(bot)

    // Process any pending message deletions from before restart
    await processStartupCleanup(db, bot.telegram)

    // Start periodic message cleanup (every 30 seconds)
    startCleanupInterval(db, bot.telegram, 30 * 1000)
    botLog.debug('Started message cleanup service')

    // Start spam vote expiration handler (check every minute)
    setInterval(() => {
      processExpiredVotes(db, bot.telegram, i18n)
    }, 60 * 1000)
    botLog.debug('Started spam vote expiration handler')

    // Start CAS (Combot Anti-Spam) sync if enabled
    startCasSync(db)
  })
}

// Start the bot
init()
